package ppl.delite.runtime.codegen

import xml.XML
import ppl.delite.runtime.Config
import ppl.delite.runtime.graph.targets.Targets
import tools.nsc.io._
import java.io.FileWriter

object CppCompile extends CCompile {

  def target = Targets.Cpp
  override def ext = "cpp"

  protected def configFile = "CPP.xml"
  protected def compileFlags = Array("-w", "-O3", "-shared", "-fPIC")
  protected def outputSwitch = "-o"
  
  private val dsFiles = Directory(Path(sourceCacheHome + "datastructures")).files.toList
  override protected def auxSourceList = dsFiles.filter(_.extension == ext).map(_.toAbsolute.toString) :+ (sourceCacheHome + "kernels" + sep + target + "helperFuncs." + ext) :+ (staticResources + "DeliteCpp." + ext)

  override def compile(destination: String, sources: Array[String], includes: Array[String], libs: Array[String]) {
    val destDir = Path(destination).parent
    destDir.createDirectory()
    
    // generate Makefile
    val makefile = destDir + File.separator + "Makefile"
    if(!Config.noRegenerate) {	  
      val degName = ppl.delite.runtime.Delite.inputArgs(0).split('.')
      val appName = degName(degName.length-2)
      val writer = new FileWriter(makefile)
      writer.write(makefileString(destination, sources, includes, libs, appName))
      writer.close()
    }

    if (config.compiler == "")
      throw new RuntimeException("compiler path is not set. Please specify in $DELITE_HOME/config/delite/CPP.xml. (<compiler> /usr/bin/g++ </compiler>")
    if (config.make == "")
      throw new RuntimeException("make command path is not set. Please specify in $DELITE_HOME/config/delite/CPP.xml. (<make> /usr/bin/make </make>")
    if (config.headerDir.length == 0)
      throw new RuntimeException("JNI header paths are not set. Please specify in $DELITE_HOME/config/delite/CPP.xml.")
    

    //TODO: How many parallel jobs? For now, the number of processors.
    val args = Array(config.make, "-s", "-j", Runtime.getRuntime.availableProcessors.toString, "-f", makefile, "all")
    println("compile command: " + args.mkString(" "))
    val process = Runtime.getRuntime.exec(args)
    process.waitFor
    checkError(process, args)
  }

  def makefileString(destination: String, sources: Array[String], includes: Array[String], libs: Array[String], output: String) = """
## Makefile: Generated by Delite Runtime ##
CC = %1$s
DELITE_HOME = %2$s
SOURCECACHE_HOME = %3$s
BINCACHE_HOME = %4$s
INCLUDES = %5$s

CFLAGS = -O3 -fPIC -w -std=c++0x
LDFLAGS = -shared -fPIC %6$s
SOURCES = %7$s
OBJECTS = $(SOURCES:.cpp=.o)
OUTPUT = $(BINCACHE_HOME)/cppHost%9$s.so

all: $(OUTPUT)

# The order of objects and libraries matter because of the dependencies
$(OUTPUT): $(OBJECTS)
	$(CC) $(OBJECTS) $(LDFLAGS) -o $(OUTPUT)

%%.o: %%.cpp
	$(CC) -c -DDELITE_CPP=%8$s $(INCLUDES) $(CFLAGS) $< -o $@ 

clean:
	rm -f $(OBJECTS) $(OUTPUT)

.PHONY: all clean
""".format(config.compiler,Config.deliteHome,sourceCacheHome,binCacheHome,includes.mkString(" "),libs.mkString(" "),sources.mkString(" "),Config.numCpp, output)

}
