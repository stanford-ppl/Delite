package ppl.delite.runtime.codegen

import org.apache.commons.io._
import scala.tools.nsc._
import scala.tools.nsc.io._
import scala.tools.nsc.util._
import collection.mutable.ArrayBuffer
import java.io.ByteArrayOutputStream
import ppl.delite.runtime.Config
import ppl.delite.runtime.graph.targets.Targets
import javax.tools._

object ScalaCompile extends CodeCache {

  private val classCacheHome = cacheHome + "classes" + sep

  def target = Targets.Scala
  def javaExt = "java"

  def compile: ClassLoader = {
    if (Config.verbose) println("[delite]: starting scala compile")
    val start = System.currentTimeMillis
    cacheRuntimeSources(sourceBuffer.toArray)
    sourceBuffer.clear()

    for (module <- modules if (module.needsCompile)) {
      val start = System.currentTimeMillis
      val sources = Directory(Path(sourceCacheHome + module.name)).deepFiles.filter(f => f.extension == ext || f.extension == javaExt).map(_.path).toArray
      val classes = module.deps.map(d => Path(classCacheHome + d.name).path).toArray
      compile(classCacheHome + module.name, sources, classes)
      val time = (System.currentTimeMillis - start)/1e3
      if (Config.verbose) println("[delite]: compiled " + module.name + " in " + time + "s")
    }
    unifyClasses()

    val time = (System.currentTimeMillis - start)/1e3
    if (Config.verbose) println("[delite]: finished scala compile in " + time + "s")
    ScalaClassLoader.fromURLs(modules.map(m => Path(classCacheHome + m.name).toURL), this.getClass.getClassLoader)
  }

  def compile(destination: String, sources: Array[String], classPaths: Array[String]) {
    val dir = Directory(Path(destination))
    dir.deleteRecursively() //clear out any old classes
    dir.createDirectory()

    val currentCp = this.getClass.getClassLoader match {
      case ctx: java.net.URLClassLoader => ctx.getURLs.map(_.getPath).mkString(File.pathSeparator)
      case _ => System.getProperty("java.class.path")
    }
    val cp = currentCp + File.pathSeparator + classPaths.mkString(File.pathSeparator)

    val bcp = Predef.getClass.getClassLoader match {
      case ctx: java.net.URLClassLoader => ctx.getURLs.map(_.getPath).mkString(File.pathSeparator)
      case _ => System.getProperty("sun.boot.class.path")
    }

    val args = Array("-nowarn", "-d", destination, "-classpath", cp, "-bootclasspath", bcp) ++ sources

    def compile() = {
      if (Config.useFsc) {
        !CompileClient.process(args)
      }
      else {
        Main.process(args) //scalac
        Main.reporter.hasErrors
      }
    }

    //this suppresses strange spurious compiler errors generated by fsc
    if (Console.withOut(new ByteArrayOutputStream)(compile())) { //try twice, suppress output on first
      if (compile()) {
        sys.error("Compilation failed")
      }
    }

    val javaSources = sources.filter(_.endsWith(javaExt))
    if (!javaSources.isEmpty) {
      //val javaCp = cp + File.pathSeparator + destination //TODO: overriding cp loses path to java standard library somehow
      val args = scala.collection.JavaConversions.asJavaIterable(Array("-nowarn", "-d", destination))
      val compiler = ToolProvider.getSystemJavaCompiler
      val fileManager = compiler.getStandardFileManager(null, null, null)
      def javaCompile() = compiler.getTask(null, fileManager, null, args, null, fileManager.getJavaFileObjects(javaSources:_*)).call()
      if (!javaCompile()) sys.error("Compilation failed")
    }
  }

  //copy all classes to a single location with matching directory structure and classpaths
  private def unifyClasses() {
    import java.io.File
    val dir = new File(classCacheHome + "jar")
    FileUtils.deleteQuietly(dir) //clear out any old classes

    for (m <- modules) {
      FileUtils.copyDirectory(new File(classCacheHome + m.name), dir, true)
    }
  }

}
