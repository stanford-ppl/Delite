package engine;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.StructFieldType;
import java.util.ArrayList;
class MemoryCmdGenLib extends KernelLib {

  protected boolean dbg = false;
  protected boolean dbgDetail = false;

  protected DFEVar getNumberOfBursts(DFEVar num, DFEType type) {
    DFEVar numburst = (num / getValuesPerBurst(type));
    return numburst;
  }

  protected DFEVar getNumberOfAlignedBursts(DFEVar elemStart, DFEVar numel, DFEType type) {
    KernelMath.DivModResult burstsMod = KernelMath.divMod(elemStart.cast(dfeUInt(32)) + numel.cast(dfeUInt(32)), constant.var(dfeUInt(32), getValuesPerBurst(type)));
    return (burstsMod.getRemainder() === constant.var(dfeUInt(32), 0)) ? burstsMod.getQuotient() : burstsMod.getQuotient() + constant.var(dfeUInt(32), 1);
  }

  protected DFEVar getBurstAddr(DFEVar elemAddr, DFEType type) {
    // Downcast to nearest burst alignment
    DFEVar burstAddr = KernelMath.divMod(elemAddr.cast(dfeUInt(32)), constant.var(dfeUInt(32), getValuesPerBurst(type))).getQuotient();
    return burstAddr;
  }

  protected DFEVar checkNewBurst(DFEVar num, DFEVar size_real, DFEType type) {
    int el_per_burst = getValuesPerBurst(type);
    DFEVar intraburst_start = KernelMath.divMod(num.cast(dfeUInt(32)), constant.var(dfeUInt(32), el_per_burst)).getRemainder();
    DFEVar sw = (num === constant.var(num.getType(), 0)  |
        intraburst_start + size_real >= el_per_burst);
    return sw;
  }

  protected DFEVar upcast(int size, DFEType type) {
    int bytes_per = type.getTotalBits()/8;
    if ((size*bytes_per) % getBurstBytes() == 0 ) {
      return constant.var(dfeUInt(32), size);
    } else {
      int upcasted = (int)(((Math.floor((size*bytes_per) / getBurstBytes()) + 1)*getBurstBytes()) / bytes_per);
      return constant.var(dfeUInt(32), upcasted);
    }
  }
  protected boolean isAligned(int size, DFEType type) {
    int bytes_per = type.getTotalBits()/8;
    if ((size*bytes_per) % getBurstBytes() == 0 ) {
      return true;
    } else {
      return false;
    }
  }

  protected void printVector(DFEVar en, DFEVector<DFEVar> v) {
    for (int i=0; i<v.getSize(); i++) {
      debug.simPrintf(en, "%f ", v[i]);
    }
      debug.simPrintf(en, "\n");
  }

  protected int getValuesPerBurst(DFEType type) {
    return getBurstSizeInBits() / type.getTotalBits();
  }

  protected int getValuesPerBurst(DFEType[] type) {
    int totalBits = 0;
    for (int i=0; i<type.length; i++) {
      totalBits += type[i].getTotalBits();
    }
    return getBurstSizeInBits() / totalBits;
  }

  protected int getBurstBytes() {
    return getManager().getManagerConfiguration().dram.getAdjustedBurstSizeInBytes();
  }
  protected int getBurstSizeInBits() {
    return 8 * getManager().getManagerConfiguration().dram.getAdjustedBurstSizeInBytes();
    // return 8 * 384;
  }

  /**
   * Parallel version which auto-detects type of wdata.
   * This means that the caller must instantiate the wdata
   * stream with the correct type.
   * The 'par' value is inferred from the length of the DFEVector
   * passed in.
   * wdata: A vector of elements read from DRAM
   */

  // Deprecated in order to change behavior if "aligned" is false
  //   since wrong data sits on fifo if reading multiple memories
  //  void common ( 
  //   KernelLib owner,
  //   DFEVar en, DFEVar done,
  //   int base, DFEVar offset,
  //   String streamName,
  //   DFEVar size, DFEVar realSize,
  //   DFEVar fifoReadEn, DFEVector<DFEVar> wdata, boolean aligned)
  // {
  //   int par = wdata.getSize();
  //   int delay = 16;
  //   SMIO sm = addStateMachine(streamName + "ldSM", new MemoryCmdSM(this));
  //   sm.connectInput("sm_en", en);
  //   done <== stream.offset(sm.getOutput("sm_done"), -1);

  //   DFEVar memDone = dfeBool().newInstance(this);
  //   sm.connectInput("memDone", memDone);
  //   DFEVar memStart = sm.getOutput("memStart");

  //   DFEVar burstAddr = base + getNumberOfBursts(offset, wdata[0].getType()).cast(dfeUInt(32));

  //   DFEVar requires_burst = aligned ? constant.var(true) : checkNewBurst(offset, realSize, wdata[0].getType());

  //   Count.Params controlCountParams = control.count.makeParams(16)
  //                             .withEnable(memStart)
  //                             .withReset(done)
  //                             .withMax(delay)
  //                             .withWrapMode(WrapMode.STOP_AT_MAX);
  //   Counter controlCounter = control.count.makeCounter(controlCountParams); // Cmd every 10 cycles
  //   DFEVar counterWrap = controlCounter.getCount() === delay-1;
  //   memDone <== stream.offset(counterWrap, -1);

  //   DFEVar ctrl = memStart & (controlCounter.getCount() === 0) & requires_burst;
  //   DFEVar len = getNumberOfBursts(size, wdata[0].getType()).cast(dfeUInt(8));
  //   DFEVar inc = constant.var(dfeUInt(8), 1);
  //   DFEVar stream = constant.var(dfeUInt(1), 0);
  //   DFEVar tag = constant.var(false);

  //   String cmdStreamName = streamName + "_cmd";
  //   LMemCommandStream.makeKernelOutput(cmdStreamName,
  //       ctrl,
  //       burstAddr,
  //       len,
  //       inc,
  //       stream,
  //       tag);

  //   debug.simPrintf(en, "[MemCmdGen] size = %d, realSize = %d, memStart = %d, ctrl = %d, offset = %d, burstAddr = %d\n", size, realSize, memStart, ctrl, offset, burstAddr);
  //   io.forceExactIOSeparation(streamName, cmdStreamName, -16);  // Arbitrarily picked to handle divides


  //   wdata <== io.input(streamName, wdata.getType(), fifoReadEn);

  //   if (dbgDetail) {
  //     debug.simPrintf(memStart, "Fetched: ");
  //     printVec(wdata, memStart);
  //   }
  // }

   void common ( 
    KernelLib owner,
    DFEVar en, DFEVar done,
    int base, DFEVar offset,
    String streamName,
    DFEVar size, DFEVar realSize,
    DFEVar fifoReadEn, DFEVector<DFEVar> wdata, boolean aligned)
  {
    int par = wdata.getSize();
    int delay = 16;
    SMIO sm = addStateMachine(streamName + "ldSM", new MemoryCmdSM(this));
    sm.connectInput("sm_en", en);
    done <== stream.offset(sm.getOutput("sm_done"), -1);

    DFEVar memDone = dfeBool().newInstance(this);
    sm.connectInput("memDone", memDone);
    DFEVar memStart = sm.getOutput("memStart");

    DFEVar burstAddr = base + getBurstAddr(offset, wdata[0].getType()).cast(dfeUInt(32));

    // DFEVar requires_burst = aligned ? constant.var(true) : checkNewBurst(offset, realSize, wdata[0].getType());

    Count.Params controlCountParams = control.count.makeParams(16)
                              .withEnable(memStart)
                              .withReset(done)
                              .withMax(delay)
                              .withWrapMode(WrapMode.STOP_AT_MAX);
    Counter controlCounter = control.count.makeCounter(controlCountParams); // Cmd every 10 cycles
    DFEVar counterWrap = controlCounter.getCount() === delay-1;
    memDone <== stream.offset(counterWrap, -1);

    DFEVar ctrl = memStart & (controlCounter.getCount() === 0);
    DFEVar len = getNumberOfAlignedBursts(offset, size, wdata[0].getType()).cast(dfeUInt(8));
    DFEVar inc = constant.var(dfeUInt(8), 1);
    DFEVar stream = constant.var(dfeUInt(1), 0);
    DFEVar tag = constant.var(false);

    String cmdStreamName = streamName + "_cmd";
    LMemCommandStream.makeKernelOutput(cmdStreamName,
        ctrl,
        burstAddr,
        len,
        inc,
        stream,
        tag);

    debug.simPrintf(en, "[MemCmdGen] size = %d, realSize = %d, memStart = %d, ctrl = %d, offset = %d, burstAddr = %d\n", size, realSize, memStart, ctrl, offset, burstAddr);
    io.forceExactIOSeparation(streamName, cmdStreamName, -16);  // Arbitrarily picked to handle divides


    wdata <== io.input(streamName, wdata.getType(), fifoReadEn);

    if (dbgDetail) {
      debug.simPrintf(memStart, "Fetched: ");
      printVec(wdata, memStart);
    }
  }

  MemoryCmdGenLib (
    KernelLib owner,
    DFEVar en, DFEVar done,
    int base, DFEVar offset,
    String streamName,
    DFEVar size,
    DFEVar fifoReadEn, DFEVector<DFEVar> wdata)
  {
    super(owner);
    common(owner, en, done, base, offset, streamName, size, size, fifoReadEn, wdata, true);
  }

MemoryCmdGenLib (
    KernelLib owner,
    DFEVar en, DFEVar done,
    int base, DFEVar offset,
    String streamName,
    DFEVar size,
    DFEVar fifoReadEn, DFEVar wdata)
  {
    super(owner);
    DFEVectorType<DFEVar> wdataType = new DFEVectorType<DFEVar>(wdata.getType(), 1);
    DFEVector<DFEVar> wdataVec = wdataType.newInstance(this);
    wdataVec[0] <== wdata;
    common(owner, en, done, base, offset, streamName, size, size, fifoReadEn, wdataVec, true);
  }

  MemoryCmdGenLib (
    KernelLib owner,
    DFEVar en, DFEVar done,
    int base, DFEVar offset,
    String streamName,
    int size_int,
    DFEVar fifoReadEn, DFEVector<DFEVar> wdata)
  {
    super(owner);
    DFEVar sizecheck = upcast(size_int, wdata[0].getType());
    DFEVar size = upcast(size_int, wdata[0].getType());
    DFEVar realSize = constant.var(dfeUInt(32), size_int);
    boolean aligned = isAligned(size_int, wdata[0].getType());
    common(owner, en, done, base, offset, streamName, size, realSize, fifoReadEn, wdata, aligned);
  }

MemoryCmdGenLib (
    KernelLib owner,
    DFEVar en, DFEVar done,
    int base, DFEVar offset,
    String streamName,
    int size_int,
    DFEVar fifoReadEn, DFEVar wdata)
  {
    super(owner);
    DFEVectorType<DFEVar> wdataType = new DFEVectorType<DFEVar>(wdata.getType(), 1);
    DFEVector<DFEVar> wdataVec = wdataType.newInstance(this);
    wdataVec[0] <== wdata;
    DFEVar size = upcast(size_int, wdata.getType());
    boolean aligned = isAligned(size_int, wdata.getType());
    DFEVar realSize = constant.var(dfeUInt(32), size_int);
    common(owner, en, done, base, offset, streamName, size, realSize, fifoReadEn, wdataVec, aligned);
  }

  void printVec(DFEVector<DFEVar> v, DFEVar en) {
    for (int i=0; i<v.getSize(); i++) {
      debug.simPrintf(en, "%d ", v[i]);
    }
    debug.simPrintf(en, "\n");
  }

  /* TODO: Optimized version where D2 is a known constant */
  /* TODO: Optimized version where entire block is loaded using
     just one memory command instead of many.
     This is possible if we know that D2 isn't large
  */
  /* TODO: Optimized version where B2 = D2. This would result in
     just one memory command instead of many.
     Maybe this can be collapsed into the previous case?
  */
}
